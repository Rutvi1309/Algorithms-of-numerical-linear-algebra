# -*- coding: utf-8 -*-
"""
Created on Wed Nov 22 17:40:08 2023

@author: rutvishah
"""

import numpy as np

def givens_rotation(a, b):
    a = 4
    b = 5
    r = np.sqrt(np.abs(a)**2 + np.abs(b)**2)
    c = a / r
    s = -b / r
    return c, s

def givens_qr(H):
    dtype = np.complex128 if np.iscomplexobj(H) else np.float64
    m+1, m == H.shape
    R = H.astype(dtype)
    G = np.zeros((m, 2), dtype=dtype)

    for k in range(m - 1):
        # Compute Givens rotation parameters
        ck, sk = givens_rotation(R[k, k], R[k+1, k])

        # Apply Givens rotation to the submatrix R[k:k+2, k:n]
        R[k:k+2, k:m] = np.dot(np.array([[ck, -sk], [sk, ck]]), R[k:k+2, k:m])

        # Store Givens rotation parameters in matrix G
        G[k, :] = [ck, sk]

    return R, G

# Example usage with complex numbers:
# Generate a random upper Hessenberg matrix with complex entries
m = 5
H = np.random.rand(m + 1, m) + 1j * np.random.rand(m + 1, m)
H = np.triu(H, -1)  # Ensure it's upper Hessenberg

print("Original Upper Hessenberg Matrix:")
print(H)

# Compute QR factorization using Givens rotations
R, G = givens_qr(H)

print("\nUpper Triangular Matrix R:")
print(R)

print("\nMatrix G (Givens Rotation Parameters):")
print(G)

def form_q(G):
    m, _ = G.shape
    Q = np.eye(m + 1, dtype=G.dtype)

    for i in range(m):
        c, s = G[i, 0], G[i, 1]

        # Construct the 2x2 Givens rotation matrix
        G_i = np.array([[c, -s], [s, c]], dtype=G.dtype)

        # Apply the Givens rotation to the corresponding columns in Q
        Q[i:i+2, :] = np.dot(G_i.T.conj(), Q[i:i+2, :])

    return Q


Q = form_q(G)

print("Unitary Matrix Q:")
print(Q)


